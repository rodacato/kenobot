#!/usr/bin/env bash
set -euo pipefail

# Security audit: scans codebase for leaked secrets, credentials, and sensitive data.
# Usage: bin/audit [--fix]

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
NC='\033[0m'

issues=0
warnings=0

fail() {
  echo -e "  ${RED}FAIL${NC} $1"
  issues=$((issues + 1))
}

warn() {
  echo -e "  ${YELLOW}WARN${NC} $1"
  warnings=$((warnings + 1))
}

pass() {
  echo -e "  ${GREEN}OK${NC}   $1"
}

section() {
  echo ""
  echo -e "${BOLD}$1${NC}"
}

# --- Tracked files to scan (excludes .gitignored files) ---

tracked_files() {
  git ls-files 2>/dev/null
}

# ============================================================
section "1. Secret patterns in tracked files"
# ============================================================

# Patterns: description | regex | file glob to exclude
declare -a patterns=(
  "Anthropic API key|sk-ant-api[0-9]+-[A-Za-z0-9_-]{20,}"
  "OpenAI API key|sk-[A-Za-z0-9]{20,}"
  "AWS access key|AKIA[0-9A-Z]{16}"
  "Google API key|AIza[0-9A-Za-z_-]{35}"
  "GitHub token|gh[ps]_[A-Za-z0-9]{36}"
  "Telegram bot token|[0-9]{8,10}:[A-Za-z0-9_-]{35}"
  "Private key header|-----BEGIN .* PRIVATE KEY-----"
  "Generic secret assignment|(?:password|secret|token|api_key)\s*[:=]\s*['\"][^'\"]{8,}['\"]"
)

found_secrets=false
for pattern_entry in "${patterns[@]}"; do
  label=$(echo "$pattern_entry" | cut -d'|' -f1)
  regex=$(echo "$pattern_entry" | cut -d'|' -f2)

  # Search tracked files only, exclude common false positives
  matches=$(git grep -lPn "$regex" -- ':!.githooks/*' ':!bin/audit' ':!*.example' ':!test/*' ':!*.md' ':!CONTRIBUTING.md' ':!SECURITY.md' 2>/dev/null || true)

  if [ -n "$matches" ]; then
    fail "$label found in: $matches"
    found_secrets=true
  fi
done

# Also check markdown/docs for real secrets (not placeholder patterns with ...)
doc_secrets=$(git grep -lPn '[0-9]{8,10}:[A-Za-z0-9_-]{35}' -- '*.md' 2>/dev/null || true)
if [ -n "$doc_secrets" ]; then
  # Check if they look like real tokens (not placeholder with dots)
  for file in $doc_secrets; do
    real_matches=$(git grep -Pn '[0-9]{8,10}:[A-Za-z0-9_-]{35}' "$file" | grep -v '\.\.\.' || true)
    if [ -n "$real_matches" ]; then
      warn "Possible Telegram token in docs: $file"
    fi
  done
fi

if [ "$found_secrets" = false ]; then
  pass "No secret patterns in source code"
fi

# ============================================================
section "2. Sensitive files tracked in git"
# ============================================================

sensitive_patterns=(.env .env.local .env.production credentials.json service-account.json '*.pem' '*.key' '*.p12' '*.pfx' '*.jks' id_rsa id_ed25519)

found_sensitive=false
for pattern in "${sensitive_patterns[@]}"; do
  matches=$(git ls-files "$pattern" 2>/dev/null || true)
  if [ -n "$matches" ]; then
    fail "Sensitive file tracked: $matches"
    found_sensitive=true
  fi
done

if [ "$found_sensitive" = false ]; then
  pass "No sensitive files tracked in git"
fi

# ============================================================
section "3. .env file permissions"
# ============================================================

if [ -f ".env" ]; then
  perms=$(stat -c "%a" .env 2>/dev/null || stat -f "%Lp" .env 2>/dev/null || echo "unknown")
  if [ "$perms" = "600" ] || [ "$perms" = "400" ]; then
    pass ".env permissions: $perms (restricted)"
  else
    warn ".env permissions: $perms (recommend 600)"
  fi
else
  pass "No .env file present"
fi

# ============================================================
section "4. Git history scan"
# ============================================================

# Check if any real secrets were ever committed (sampling common patterns)
history_patterns=(
  'sk-ant-api[0-9]+-[A-Za-z0-9_-]{20}'
  'AKIA[0-9A-Z]{16}'
  'ghp_[A-Za-z0-9]{36}'
)

found_history=false
for pattern in "${history_patterns[@]}"; do
  # Search history but exclude hook/audit files (they contain patterns for detection)
  matches=$(git log -p --all -S "$pattern" -- ':!.githooks/*' ':!bin/audit' 2>/dev/null | head -1 || true)
  if [ -n "$matches" ]; then
    fail "Secret pattern found in git history: $pattern"
    found_history=true
  fi
done

if [ "$found_history" = false ]; then
  pass "No secrets found in git history"
fi

# ============================================================
section "5. Personal identifiers in tracked files"
# ============================================================

# Check for hardcoded Telegram chat IDs (skip generic examples like 123456789)
pii_files=$(git grep -Pn 'CHAT_IDS?\s*[:=]\s*[0-9]{6,}' -- ':!.env.example' ':!bin/audit' ':!test/*' 2>/dev/null \
  | grep -vE '123456789|987654321|111222333|PASTE_|YOUR_' || true)
if [ -n "$pii_files" ]; then
  warn "Possible real chat/user IDs in tracked files:"
  echo "$pii_files" | while read -r line; do echo "         $line"; done
else
  pass "No real chat/user IDs in tracked files"
fi

# ============================================================
section "6. Pre-commit hook coverage"
# ============================================================

hook_file=".githooks/pre-commit"
if [ -f "$hook_file" ]; then
  missing_patterns=()

  if ! grep -qF '[0-9]{8,10}:[A-Za-z0-9_-]{35}' "$hook_file" 2>/dev/null; then
    missing_patterns+=("Telegram bot token")
  fi

  if ! grep -q 'sk-ant\|anthropic\|ANTHROPIC' "$hook_file" 2>/dev/null; then
    missing_patterns+=("Anthropic API key")
  fi

  if [ ${#missing_patterns[@]} -gt 0 ]; then
    warn "Pre-commit hook missing patterns: ${missing_patterns[*]}"
  else
    pass "Pre-commit hook covers common secret patterns"
  fi
else
  warn "No pre-commit hook found at $hook_file"
fi

# ============================================================
section "7. Data directory"
# ============================================================

if [ -d "data" ]; then
  if git ls-files data/ 2>/dev/null | grep -q .; then
    fail "Files in data/ are tracked in git (should be gitignored)"
  else
    pass "data/ directory is gitignored"
  fi
else
  pass "No data/ directory"
fi

# ============================================================
# Summary
# ============================================================

echo ""
echo -e "${BOLD}─────────────────────────────────────${NC}"

if [ "$issues" -gt 0 ]; then
  echo -e "${RED}${BOLD}FAILED${NC}: $issues issue(s), $warnings warning(s)"
  exit 1
elif [ "$warnings" -gt 0 ]; then
  echo -e "${YELLOW}${BOLD}PASSED with warnings${NC}: $warnings warning(s)"
  exit 0
else
  echo -e "${GREEN}${BOLD}PASSED${NC}: No issues found"
  exit 0
fi
